import os
import json
import logging
from telegram import Update
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, ContextTypes
)
from dotenv import load_dotenv
from utils import check_password, verify_user, is_verified, change_password, txt_to_vcf

# Load environment variables
load_dotenv()
TOKEN = "7228313489:AAFS1N8i-Q1sB8Y93jm9IkMKXGp46ZBOOoY"
OWNER_ID = 7706131450  # Replace with your actual Telegram user ID

# Configure logging
logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)

# Store temporary user data
user_data = {}

CONFIG_FILE = "config.json"

# Load configuration
def load_config():
    if not os.path.exists(CONFIG_FILE):
        return {"verified_users": []}
    with open(CONFIG_FILE, "r") as file:
        return json.load(file)

# Save configuration
def save_config(config):
    with open(CONFIG_FILE, "w") as file:
        json.dump(config, file)

# Start command
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Welcome! Please enter the bot password to proceed.")

# Password handler
async def password_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    password = update.message.text.strip()

    if is_verified(user_id):
        await update.message.reply_text("‚úÖ You are already verified! Send a .txt file to convert.")
        return

    if check_password(user_id, password):
        verify_user(user_id)
        await update.message.reply_text("‚úÖ Password correct! Send a .txt file to convert.")
    else:
        await update.message.reply_text("‚ùå Incorrect password. Please try again.")

# Handle .txt file upload
async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id

    if not is_verified(user_id):
        await update.message.reply_text("‚ùå You must enter the correct password first.")
        return

    file = update.message.document
    if file.mime_type != "text/plain":
        await update.message.reply_text("‚ùå Please send a valid .txt file.")
        return

    file_path = f"downloads/{file.file_name}"
    os.makedirs("downloads", exist_ok=True)
    new_file = await file.get_file()
    await new_file.download_to_drive(file_path)

    user_data[user_id] = {"file_path": file_path}
    await update.message.reply_text("üìå Please enter a base name for contacts (or type 'auto' to auto-generate).")

# Handle contact naming
async def handle_contact_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    name = update.message.text.strip()

    if user_id not in user_data or "file_path" not in user_data[user_id]:
        await update.message.reply_text("‚ùå Please send a .txt file first.")
        return

    user_data[user_id]["contact_name"] = name
    await update.message.reply_text("üìå Now enter a name for the .vcf file.")

    # Change the handler to listen for VCF file name
    context.user_data["awaiting_vcf_name"] = True

# Handle VCF file naming
async def handle_vcf_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    vcf_name = update.message.text.strip()

    if not context.user_data.get("awaiting_vcf_name"):
        await update.message.reply_text("‚ùå Please send a .txt file and enter a base contact name first.")
        return

    if user_id not in user_data or "contact_name" not in user_data[user_id]:
        await update.message.reply_text("‚ùå Please enter the contact name first.")
        return

    txt_file = user_data[user_id]["file_path"]
    contact_name = user_data[user_id]["contact_name"]
    vcf_file = f"downloads/{vcf_name}.vcf"

    # Convert txt to vcf
    txt_to_vcf(txt_file, vcf_file, contact_name)

    await update.message.reply_document(document=open(vcf_file, "rb"), filename=vcf_name + ".vcf")
    await update.message.reply_text("‚úÖ Here is your converted .vcf file!")

    # Clear temporary data
    del user_data[user_id]
    context.user_data["awaiting_vcf_name"] = False

# Change password (owner only)
async def change_password_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    if user_id != OWNER_ID:
        await update.message.reply_text("‚ùå You are not authorized to change the password.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /changepass <new_password>")
        return

    new_password = context.args[0]
    change_password(new_password)
    await update.message.reply_text("üîí Password has been changed. All users must re-enter the new password.")

# Help command
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
üîπ Send a .txt file to convert it to .vcf.
üîπ If no contact names are found, you will be asked to enter one.
üîπ You can rename the .vcf file before receiving it.
üîπ Commands:
  /start - Restart from the beginning
  /changepass <new_pass> - Change password (Owner only)
  /status - Check bot status
  /help - Show this help menu
"""
    await update.message.reply_text(help_text)

# Status command
async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    config = load_config()
    verified_count = len(config["verified_users"])
    await update.message.reply_text(f"‚úÖ Bot is running.\nüë• Verified users: {verified_count}")

# Main function
def main():
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("changepass", change_password_command))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("status", status_command))

    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, password_handler))
    app.add_handler(MessageHandler(filters.Document.ALL & filters.Document.MimeType("text/plain"), handle_document))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_contact_name))

    # Ensure VCF naming only triggers after contact name step
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_vcf_name))

    app.run_polling()

if __name__ == "__main__":
    main()