import os
import json
import logging
from telegram import Update, Document
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, CallbackContext
)
from dotenv import load_dotenv
from utils import check_password, verify_user, is_verified, change_password, txt_to_vcf

# Load environment variables
load_dotenv()
TOKEN = "7228313489:AAFS1N8i-Q1sB8Y93jm9IkMKXGp46ZBOOoY"
OWNER_ID = 7706131450  # Replace with your actual Telegram user ID

# Configure logging
logging.basicConfig(format="%(asctime)s - %(levelname)s - %(message)s", level=logging.INFO)

# Store temporary data for user interactions
user_data = {}

CONFIG_FILE = "config.json"

# Start command
async def start(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    user_data[user_id] = {"step": "awaiting_password"}  # Reset user data
    await update.message.reply_text("Welcome! Please enter the bot password to proceed.")

# Password handler
async def password_handler(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    password = update.message.text.strip()

    if is_verified(user_id):
        await update.message.reply_text("âœ… You are already verified! Send a .txt file to convert.")
        return

    if check_password(user_id, password):
        verify_user(user_id)
        user_data[user_id] = {"step": "awaiting_file"}  # Move to next step
        await update.message.reply_text("âœ… Password correct! Send a .txt file to convert.")
    else:
        await update.message.reply_text("âŒ Incorrect password. Please try again.")

# Handle received text files
async def handle_document(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id

    if not is_verified(user_id):
        await update.message.reply_text("âŒ You must enter the correct password first.")
        return

    file = update.message.document
    if file.mime_type != "text/plain":
        await update.message.reply_text("âŒ Please send a valid .txt file.")
        return

    file_path = f"downloads/{file.file_name}"
    os.makedirs("downloads", exist_ok=True)
    new_file = await file.get_file()
    await new_file.download_to_drive(file_path)

    user_data[user_id] = {"step": "awaiting_contact_name", "file_path": file_path}
    await update.message.reply_text("ğŸ“Œ Please enter a base name for contacts (or type 'auto' to auto-generate).")

# Handle contact naming
async def handle_contact_name(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    name = update.message.text.strip()

    if user_id not in user_data or user_data[user_id]["step"] != "awaiting_contact_name":
        await update.message.reply_text("âŒ Please send a .txt file first.")
        return

    user_data[user_id]["contact_name"] = name
    user_data[user_id]["step"] = "awaiting_vcf_name"
    await update.message.reply_text("ğŸ“Œ Now enter a name for the .vcf file.")

# Handle VCF file naming
async def handle_vcf_name(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    vcf_name = update.message.text.strip()

    if user_id not in user_data or user_data[user_id]["step"] != "awaiting_vcf_name":
        await update.message.reply_text("âŒ Please enter the contact name first.")
        return

    txt_file = user_data[user_id]["file_path"]
    contact_name = user_data[user_id]["contact_name"]
    vcf_file = f"downloads/{vcf_name}.vcf"

    txt_to_vcf(txt_file, vcf_file, contact_name)

    await update.message.reply_document(document=open(vcf_file, "rb"), filename=vcf_name + ".vcf")
    await update.message.reply_text("âœ… Here is your converted .vcf file!")

    del user_data[user_id]  # Clear temporary data

# Change password (owner only)
async def change_password_command(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    if user_id != OWNER_ID:
        await update.message.reply_text("âŒ You are not authorized to change the password.")
        return

    if len(context.args) != 1:
        await update.message.reply_text("Usage: /changepass <new_password>")
        return

    new_password = context.args[0]
    change_password(new_password)
    await update.message.reply_text("ğŸ”’ Password has been changed. All users must re-enter the new password.")

# Help command
async def help_command(update: Update, context: CallbackContext):
    help_text = """
ğŸ”¹ Send a .txt file to convert it to .vcf.
ğŸ”¹ If no contact names are found, you will be asked to enter one.
ğŸ”¹ You can rename the .vcf file before receiving it.
ğŸ”¹ Commands:
  /start - Restart from the beginning
  /changepass <new_pass> - Change password (Owner only)
  /status - Check bot status
  /help - Show this help menu
"""
    await update.message.reply_text(help_text)

# Status command
async def status_command(update: Update, context: CallbackContext):
    config = load_config()
    verified_count = len(config["verified_users"])
    await update.message.reply_text(f"âœ… Bot is running.\nğŸ‘¥ Verified users: {verified_count}")

# Main function
def main():
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("changepass", change_password_command))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("status", status_command))

    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, password_handler))
    app.add_handler(MessageHandler(filters.Document.ALL & filters.Document.MimeType("text/plain"), handle_document))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_contact_name))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_vcf_name))

    app.run_polling()

if __name__ == "__main__":
    main()